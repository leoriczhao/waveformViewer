#include "gl_surface.hpp"
#include "glad/glad.h"
#include <cstdio>

namespace wv {

static const char* vertexShaderSrc = R"(
#version 330 core
layout(location = 0) in vec2 aPos;
layout(location = 1) in vec4 aColor;
out vec4 vColor;
uniform vec2 uResolution;
void main() {
    vec2 pos = (aPos / uResolution) * 2.0 - 1.0;
    pos.y = -pos.y;
    gl_Position = vec4(pos, 0.0, 1.0);
    vColor = aColor;
}
)";

static const char* fragmentShaderSrc = R"(
#version 330 core
in vec4 vColor;
out vec4 fragColor;
void main() {
    fragColor = vColor;
}
)";

static const char* textVertexShaderSrc = R"(
#version 330 core
layout(location = 0) in vec2 aPos;
layout(location = 1) in vec2 aUv;
out vec2 vUv;
uniform vec2 uResolution;
void main() {
    vec2 pos = (aPos / uResolution) * 2.0 - 1.0;
    pos.y = -pos.y;
    gl_Position = vec4(pos, 0.0, 1.0);
    vUv = aUv;
}
)";

static const char* textFragmentShaderSrc = R"(
#version 330 core
in vec2 vUv;
out vec4 fragColor;
uniform sampler2D uTex;
uniform vec4 uColor;
void main() {
    float a = texture(uTex, vUv).r;
    fragColor = vec4(uColor.rgb, uColor.a * a);
}
)";

static const u8 fontData[][13] = {
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x36,0x36,0x36,0x36},
    {0x00,0x00,0x00,0x66,0x66,0xff,0x66,0x66,0xff,0x66,0x66,0x00,0x00},
    {0x00,0x00,0x18,0x7e,0xff,0x1b,0x1f,0x7e,0xf8,0xd8,0xff,0x7e,0x18},
    {0x00,0x00,0x0e,0x1b,0xdb,0x6e,0x30,0x18,0x0c,0x76,0xdb,0xd8,0x70},
    {0x00,0x00,0x7f,0xc6,0xcf,0xd8,0x70,0x70,0xd8,0xcc,0xcc,0x6c,0x38},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x1c,0x0c,0x0e},
    {0x00,0x00,0x0c,0x18,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x18,0x0c},
    {0x00,0x00,0x30,0x18,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x18,0x30},
    {0x00,0x00,0x00,0x00,0x99,0x5a,0x3c,0xff,0x3c,0x5a,0x99,0x00,0x00},
    {0x00,0x00,0x00,0x18,0x18,0x18,0xff,0xff,0x18,0x18,0x18,0x00,0x00},
    {0x00,0x00,0x30,0x18,0x1c,0x1c,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x38,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x60,0x60,0x30,0x30,0x18,0x18,0x0c,0x0c,0x06,0x06,0x03,0x03},
    {0x00,0x00,0x3c,0x66,0xc3,0xe3,0xf3,0xdb,0xcf,0xc7,0xc3,0x66,0x3c},
    {0x00,0x00,0x7e,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x78,0x38,0x18},
    {0x00,0x00,0xff,0xc0,0xc0,0x60,0x30,0x18,0x0c,0x06,0x03,0xe7,0x7e},
    {0x00,0x00,0x7e,0xe7,0x03,0x03,0x07,0x7e,0x07,0x03,0x03,0xe7,0x7e},
    {0x00,0x00,0x0c,0x0c,0x0c,0x0c,0x0c,0xff,0xcc,0x6c,0x3c,0x1c,0x0c},
    {0x00,0x00,0x7e,0xe7,0x03,0x03,0x07,0xfe,0xc0,0xc0,0xc0,0xc0,0xff},
    {0x00,0x00,0x7e,0xe7,0xc3,0xc3,0xc7,0xfe,0xc0,0xc0,0xc0,0xe7,0x7e},
    {0x00,0x00,0x30,0x30,0x30,0x30,0x18,0x0c,0x06,0x03,0x03,0x03,0xff},
    {0x00,0x00,0x7e,0xe7,0xc3,0xc3,0xe7,0x7e,0xe7,0xc3,0xc3,0xe7,0x7e},
    {0x00,0x00,0x7e,0xe7,0x03,0x03,0x03,0x7f,0xe7,0xc3,0xc3,0xe7,0x7e},
    {0x00,0x00,0x00,0x38,0x38,0x00,0x00,0x38,0x38,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x30,0x18,0x1c,0x1c,0x00,0x00,0x1c,0x1c,0x00,0x00,0x00},
    {0x00,0x00,0x06,0x0c,0x18,0x30,0x60,0xc0,0x60,0x30,0x18,0x0c,0x06},
    {0x00,0x00,0x00,0x00,0xff,0xff,0x00,0xff,0xff,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x60,0x30,0x18,0x0c,0x06,0x03,0x06,0x0c,0x18,0x30,0x60},
    {0x00,0x00,0x18,0x00,0x00,0x18,0x18,0x0c,0x06,0x03,0xc3,0xc3,0x7e},
    {0x00,0x00,0x3f,0x60,0xcf,0xdb,0xd3,0xdd,0xc3,0x7e,0x00,0x00,0x00},
    {0x00,0x00,0xc3,0xc3,0xc3,0xc3,0xff,0xc3,0xc3,0xc3,0x66,0x3c,0x18},
    {0x00,0x00,0xfe,0xc7,0xc3,0xc3,0xc7,0xfe,0xc7,0xc3,0xc3,0xc7,0xfe},
    {0x00,0x00,0x7e,0xe7,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xe7,0x7e},
    {0x00,0x00,0xfc,0xce,0xc7,0xc3,0xc3,0xc3,0xc3,0xc3,0xc7,0xce,0xfc},
    {0x00,0x00,0xff,0xc0,0xc0,0xc0,0xc0,0xfc,0xc0,0xc0,0xc0,0xc0,0xff},
    {0x00,0x00,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xfc,0xc0,0xc0,0xc0,0xff},
    {0x00,0x00,0x7e,0xe7,0xc3,0xc3,0xcf,0xc0,0xc0,0xc0,0xc0,0xe7,0x7e},
    {0x00,0x00,0xc3,0xc3,0xc3,0xc3,0xc3,0xff,0xc3,0xc3,0xc3,0xc3,0xc3},
    {0x00,0x00,0x7e,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x7e},
    {0x00,0x00,0x7c,0xee,0xc6,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x1e},
    {0x00,0x00,0xc3,0xc6,0xcc,0xd8,0xf0,0xe0,0xf0,0xd8,0xcc,0xc6,0xc3},
    {0x00,0x00,0xff,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0},
    {0x00,0x00,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xdb,0xff,0xff,0xe7,0xc3},
    {0x00,0x00,0xc7,0xc7,0xcf,0xcf,0xdf,0xdb,0xfb,0xf3,0xf3,0xe3,0xe3},
    {0x00,0x00,0x7e,0xe7,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xe7,0x7e},
    {0x00,0x00,0xc0,0xc0,0xc0,0xc0,0xc0,0xfe,0xc7,0xc3,0xc3,0xc7,0xfe},
    {0x00,0x00,0x3f,0x6e,0xdf,0xdb,0xc3,0xc3,0xc3,0xc3,0xc3,0x66,0x3c},
    {0x00,0x00,0xc3,0xc6,0xcc,0xd8,0xf0,0xfe,0xc7,0xc3,0xc3,0xc7,0xfe},
    {0x00,0x00,0x7e,0xe7,0x03,0x03,0x07,0x7e,0xe0,0xc0,0xc0,0xe7,0x7e},
    {0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xff},
    {0x00,0x00,0x7e,0xe7,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3},
    {0x00,0x00,0x18,0x3c,0x3c,0x66,0x66,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3},
    {0x00,0x00,0xc3,0xe7,0xff,0xff,0xdb,0xdb,0xc3,0xc3,0xc3,0xc3,0xc3},
    {0x00,0x00,0xc3,0x66,0x66,0x3c,0x3c,0x18,0x3c,0x3c,0x66,0x66,0xc3},
    {0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x3c,0x3c,0x66,0x66,0xc3},
    {0x00,0x00,0xff,0xc0,0xc0,0x60,0x30,0x7e,0x0c,0x06,0x03,0x03,0xff},
    {0x00,0x00,0x3c,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3c},
    {0x00,0x03,0x03,0x06,0x06,0x0c,0x0c,0x18,0x18,0x30,0x30,0x60,0x60},
    {0x00,0x00,0x3c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x3c},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc3,0x66,0x3c,0x18},
    {0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x38,0x30},
    {0x00,0x00,0x7f,0xc3,0xc3,0x7f,0x03,0xc3,0x7e,0x00,0x00,0x00,0x00},
    {0x00,0x00,0xfe,0xc3,0xc3,0xc3,0xc3,0xfe,0xc0,0xc0,0xc0,0xc0,0xc0},
    {0x00,0x00,0x7e,0xc3,0xc0,0xc0,0xc0,0xc3,0x7e,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x7f,0xc3,0xc3,0xc3,0xc3,0x7f,0x03,0x03,0x03,0x03,0x03},
    {0x00,0x00,0x7f,0xc0,0xc0,0xfe,0xc3,0xc3,0x7e,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x30,0x30,0x30,0x30,0x30,0xfc,0x30,0x30,0x30,0x33,0x1e},
    {0x7e,0xc3,0x03,0x03,0x7f,0xc3,0xc3,0xc3,0x7e,0x00,0x00,0x00,0x00},
    {0x00,0x00,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xfe,0xc0,0xc0,0xc0,0xc0},
    {0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x18,0x00},
    {0x38,0x6c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x00,0x00,0x0c,0x00},
    {0x00,0x00,0xc6,0xcc,0xf8,0xf0,0xd8,0xcc,0xc6,0xc0,0xc0,0xc0,0xc0},
    {0x00,0x00,0x7e,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x78},
    {0x00,0x00,0xdb,0xdb,0xdb,0xdb,0xdb,0xdb,0xfe,0x00,0x00,0x00,0x00},
    {0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xfc,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00},
    {0xc0,0xc0,0xc0,0xfe,0xc3,0xc3,0xc3,0xc3,0xfe,0x00,0x00,0x00,0x00},
    {0x03,0x03,0x03,0x7f,0xc3,0xc3,0xc3,0xc3,0x7f,0x00,0x00,0x00,0x00},
    {0x00,0x00,0xc0,0xc0,0xc0,0xc0,0xc0,0xe0,0xfe,0x00,0x00,0x00,0x00},
    {0x00,0x00,0xfe,0x03,0x03,0x7e,0xc0,0xc0,0x7f,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x1c,0x36,0x30,0x30,0x30,0x30,0xfc,0x30,0x30,0x30,0x00},
    {0x00,0x00,0x7e,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x18,0x3c,0x3c,0x66,0x66,0xc3,0xc3,0x00,0x00,0x00,0x00},
    {0x00,0x00,0xc3,0xe7,0xff,0xdb,0xc3,0xc3,0xc3,0x00,0x00,0x00,0x00},
    {0x00,0x00,0xc3,0x66,0x3c,0x18,0x3c,0x66,0xc3,0x00,0x00,0x00,0x00},
    {0xf8,0x0c,0x06,0x7e,0xc6,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00},
    {0x00,0x00,0xfe,0x60,0x30,0x18,0x0c,0x06,0xfe,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x0e,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x18,0x18,0x0e},
    {0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18},
    {0x00,0x00,0x70,0x18,0x18,0x18,0x0e,0x18,0x18,0x18,0x18,0x18,0x70},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8c,0xd6,0x62,0x00},
};

XVisualInfo* GlSurface::chooseVisual(Display* dpy) {
    int attribs[] = { GLX_RGBA, GLX_DOUBLEBUFFER, GLX_DEPTH_SIZE, 0, None };
    return glXChooseVisual(dpy, DefaultScreen(dpy), attribs);
}

void GlSurface::init(SurfaceID sid, i32 w, i32 h) {
    display_ = static_cast<Display*>(sid);
    w_ = w;
    h_ = h;
}

bool GlSurface::setWindow(Window win, XVisualInfo* vi) {
    win_ = win;
    XVisualInfo* localVi = vi ? vi : chooseVisual(display_);
    if (!localVi) return false;
    
    ctx_ = glXCreateContext(display_, localVi, nullptr, True);
    if (!vi) XFree(localVi);
    if (!ctx_) return false;
    if (!glXMakeCurrent(display_, win_, ctx_)) return false;
    if (!gladLoadGL()) return false;
    if (!initGL()) return false;
    
    return true;
}

void GlSurface::resize(i32 w, i32 h) {
    w_ = w;
    h_ = h;
    if (ctx_) {
        glViewport(0, 0, w, h);
    }
}

void GlSurface::release() {
    if (textShader_) {
        glDeleteProgram(textShader_);
        textShader_ = 0;
    }
    if (textVbo_) {
        glDeleteBuffers(1, &textVbo_);
        textVbo_ = 0;
    }
    if (textVao_) {
        glDeleteVertexArrays(1, &textVao_);
        textVao_ = 0;
    }
    if (fontTex_) {
        glDeleteTextures(1, &fontTex_);
        fontTex_ = 0;
    }
    if (shader_) {
        glDeleteProgram(shader_);
        shader_ = 0;
    }
    if (vbo_) {
        glDeleteBuffers(1, &vbo_);
        vbo_ = 0;
    }
    if (vao_) {
        glDeleteVertexArrays(1, &vao_);
        vao_ = 0;
    }
    if (ctx_) {
        glXMakeCurrent(display_, None, nullptr);
        glXDestroyContext(display_, ctx_);
        ctx_ = nullptr;
    }
}

bool GlSurface::initGL() {
    shader_ = createProgram(vertexShaderSrc, fragmentShaderSrc);
    if (!shader_) return false;
    resolutionLoc_ = glGetUniformLocation(shader_, "uResolution");
    
    glGenVertexArrays(1, &vao_);
    glGenBuffers(1, &vbo_);
    
    glBindVertexArray(vao_);
    glBindBuffer(GL_ARRAY_BUFFER, vbo_);
    
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0);
    glEnableVertexAttribArray(0);
    
    glVertexAttribPointer(1, 4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(Vertex), (void*)(2 * sizeof(f32)));
    glEnableVertexAttribArray(1);
    
    glBindVertexArray(0);
    
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    
    initFont();
    
    return true;
}

u32 GlSurface::compileShader(u32 type, const char* src) {
    u32 shader = glCreateShader(type);
    glShaderSource(shader, 1, &src, nullptr);
    glCompileShader(shader);
    
    i32 success;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
    if (!success) {
        char log[512];
        glGetShaderInfoLog(shader, 512, nullptr, log);
        fprintf(stderr, "Shader compile error: %s\n", log);
        glDeleteShader(shader);
        return 0;
    }
    
    return shader;
}

u32 GlSurface::createProgram(const char* vs, const char* fs) {
    u32 v = compileShader(GL_VERTEX_SHADER, vs);
    if (!v) return 0;
    u32 f = compileShader(GL_FRAGMENT_SHADER, fs);
    if (!f) {
        glDeleteShader(v);
        return 0;
    }
    u32 prog = glCreateProgram();
    glAttachShader(prog, v);
    glAttachShader(prog, f);
    glLinkProgram(prog);
    
    i32 success;
    glGetProgramiv(prog, GL_LINK_STATUS, &success);
    
    glDeleteShader(v);
    glDeleteShader(f);
    
    if (!success) {
        char log[512];
        glGetProgramInfoLog(prog, 512, nullptr, log);
        fprintf(stderr, "Program link error: %s\n", log);
        glDeleteProgram(prog);
        return 0;
    }
    
    return prog;
}

void GlSurface::initFont() {
    textShader_ = createProgram(textVertexShaderSrc, textFragmentShaderSrc);
    if (!textShader_) return;
    textResLoc_ = glGetUniformLocation(textShader_, "uResolution");
    
    glGenTextures(1, &fontTex_);
    glBindTexture(GL_TEXTURE_2D, fontTex_);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    
    const i32 glyphW = 8;
    const i32 glyphH = 13;
    const i32 cols = 16;
    const i32 rows = 6;
    const i32 texW = cols * glyphW;
    const i32 texH = rows * glyphH;
    
    std::vector<u8> tex(texW * texH, 0);
    for (i32 g = 0; g < 95; ++g) {
        i32 row = g / cols;
        i32 col = g % cols;
        for (i32 y = 0; y < glyphH; ++y) {
            u8 bits = fontData[g][y];
            for (i32 x = 0; x < glyphW; ++x) {
                u8 v = (bits & (1 << (7 - x))) ? 255 : 0;
                i32 dstX = col * glyphW + x;
                i32 dstY = row * glyphH + y;
                tex[dstY * texW + dstX] = v;
            }
        }
    }
    
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RED, texW, texH, 0, GL_RED, GL_UNSIGNED_BYTE, tex.data());
    
    glGenVertexArrays(1, &textVao_);
    glGenBuffers(1, &textVbo_);
    glBindVertexArray(textVao_);
    glBindBuffer(GL_ARRAY_BUFFER, textVbo_);
    glBufferData(GL_ARRAY_BUFFER, sizeof(f32) * 24, nullptr, GL_STREAM_DRAW);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(f32) * 4, (void*)0);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(f32) * 4, (void*)(2 * sizeof(f32)));
    glEnableVertexAttribArray(1);
    glBindVertexArray(0);
}

void GlSurface::beginFrame() {
    if (!ctx_) return;
    glXMakeCurrent(display_, win_, ctx_);
    glViewport(0, 0, w_, h_);
    glDisable(GL_SCISSOR_TEST);
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);
    lineVertices_.clear();
    triVertices_.clear();
}

void GlSurface::endFrame() {
    flushTriangles();
    flushLines();
    glXSwapBuffers(display_, win_);
}

void GlSurface::flushLines() {
    if (lineVertices_.empty()) return;
    glUseProgram(shader_);
    glUniform2f(resolutionLoc_, f32(w_), f32(h_));
    glBindVertexArray(vao_);
    glBindBuffer(GL_ARRAY_BUFFER, vbo_);
    glBufferData(GL_ARRAY_BUFFER, lineVertices_.size() * sizeof(Vertex), lineVertices_.data(), GL_STREAM_DRAW);
    glDrawArrays(GL_LINES, 0, i32(lineVertices_.size()));
    glBindVertexArray(0);
    lineVertices_.clear();
}

void GlSurface::flushTriangles() {
    if (triVertices_.empty()) return;
    glUseProgram(shader_);
    glUniform2f(resolutionLoc_, f32(w_), f32(h_));
    glBindVertexArray(vao_);
    glBindBuffer(GL_ARRAY_BUFFER, vbo_);
    glBufferData(GL_ARRAY_BUFFER, triVertices_.size() * sizeof(Vertex), triVertices_.data(), GL_STREAM_DRAW);
    glDrawArrays(GL_TRIANGLES, 0, i32(triVertices_.size()));
    glBindVertexArray(0);
    triVertices_.clear();
}

void GlSurface::fillRect(Rect r, Color c) {
    Vertex v0 = {r.x, r.y, c.r, c.g, c.b, c.a};
    Vertex v1 = {r.x + r.w, r.y, c.r, c.g, c.b, c.a};
    Vertex v2 = {r.x + r.w, r.y + r.h, c.r, c.g, c.b, c.a};
    Vertex v3 = {r.x, r.y + r.h, c.r, c.g, c.b, c.a};
    
    triVertices_.push_back(v0);
    triVertices_.push_back(v1);
    triVertices_.push_back(v2);
    triVertices_.push_back(v0);
    triVertices_.push_back(v2);
    triVertices_.push_back(v3);
}

void GlSurface::strokeRect(Rect r, Color c, f32 width) {
    drawLine({r.x, r.y}, {r.x + r.w, r.y}, c, width);
    drawLine({r.x + r.w, r.y}, {r.x + r.w, r.y + r.h}, c, width);
    drawLine({r.x + r.w, r.y + r.h}, {r.x, r.y + r.h}, c, width);
    drawLine({r.x, r.y + r.h}, {r.x, r.y}, c, width);
}

void GlSurface::drawLine(Point p1, Point p2, Color c, f32) {
    lineVertices_.push_back({p1.x, p1.y, c.r, c.g, c.b, c.a});
    lineVertices_.push_back({p2.x, p2.y, c.r, c.g, c.b, c.a});
}

void GlSurface::drawPolyline(const Point* pts, i32 count, Color c, f32 width) {
    for (i32 i = 0; i < count - 1; ++i) {
        drawLine(pts[i], pts[i + 1], c, width);
    }
}

void GlSurface::drawText(Point p, std::string_view text, Color c) {
    if (!textShader_ || !fontTex_) return;
    
    const f32 glyphW = 8.0f;
    const f32 glyphH = 13.0f;
    const f32 texW = 16.0f * glyphW;
    const f32 texH = 6.0f * glyphH;
    const f32 invTexW = 1.0f / texW;
    const f32 invTexH = 1.0f / texH;
    
    flushTriangles();
    flushLines();
    
    glUseProgram(textShader_);
    glUniform2f(textResLoc_, f32(w_), f32(h_));
    i32 colorLoc = glGetUniformLocation(textShader_, "uColor");
    glUniform4f(colorLoc, c.r / 255.0f, c.g / 255.0f, c.b / 255.0f, c.a / 255.0f);
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, fontTex_);
    i32 texLoc = glGetUniformLocation(textShader_, "uTex");
    glUniform1i(texLoc, 0);
    glBindVertexArray(textVao_);
    
    f32 x = p.x;
    for (char ch : text) {
        if (ch < 32 || ch > 126) ch = '?';
        i32 idx = ch - 32;
        i32 col = idx & 15;
        i32 row = idx >> 4;
        f32 u0 = f32(col) * glyphW * invTexW;
        f32 v0 = f32(row) * glyphH * invTexH;
        f32 u1 = u0 + glyphW * invTexW;
        f32 v1 = v0 + glyphH * invTexH;
        
        f32 verts[] = {
            x, p.y, u0, v1,
            x + glyphW, p.y, u1, v1,
            x + glyphW, p.y + glyphH, u1, v0,
            x, p.y, u0, v1,
            x + glyphW, p.y + glyphH, u1, v0,
            x, p.y + glyphH, u0, v0
        };
        glBindBuffer(GL_ARRAY_BUFFER, textVbo_);
        glBufferData(GL_ARRAY_BUFFER, sizeof(verts), verts, GL_STREAM_DRAW);
        glDrawArrays(GL_TRIANGLES, 0, 6);
        x += glyphW;
    }
    glBindVertexArray(0);
}

void GlSurface::setClip(Rect r) {
    flushTriangles();
    flushLines();
    glEnable(GL_SCISSOR_TEST);
    glScissor(i32(r.x), h_ - i32(r.y + r.h), i32(r.w), i32(r.h));
}

void GlSurface::clearClip() {
    flushTriangles();
    flushLines();
    glDisable(GL_SCISSOR_TEST);
}

}
